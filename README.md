# Сервис динамического сегментирования пользователей

> Ход решения представлен в конце файла

## Проблема:
В Авито часто проводятся различные эксперименты — тесты новых продуктов, тесты интерфейса, скидочные и многие другие. На архитектурном комитете приняли решение централизовать работу с проводимыми экспериментами и вынести этот функционал в отдельный сервис.

## Задача:
Требуется реализовать сервис, хранящий пользователя и сегменты, в которых он состоит (создание, изменение, удаление сегментов, а также добавление и удаление пользователей в сегмент)

## Требования и детали по заданию
### Технические требования:

1. Сервис должен предоставлять HTTP API с форматом JSON как при отправке запроса, так и при получении результата.
2. Язык разработки: Golang.
3. Фреймворки и библиотеки можно использовать любые.
4. Реляционная СУБД: MySQL или PostgreSQL.
5. Использование docker и docker-compose для поднятия и развертывания dev-среды.
6. Весь код должен быть выложен на Github/Gitlab с Readme файлом с инструкцией по запуску и примерами запросов/ответов (можно просто описать в Readme методы, можно через Postman, можно в Readme curl запросы скопировать, и так далее).
7. Если есть потребность в асинхронных сценариях, то использование любых систем очередей - допускается.
8. При возникновении вопросов по ТЗ оставляем принятие решения за кандидатом (в таком случае в Readme файле к проекту должен быть указан список вопросов, с которыми кандидат столкнулся и каким образом он их решил).
9. Разработка интерфейса в браузере НЕ ТРЕБУЕТСЯ. Взаимодействие с API предполагается посредством запросов из кода другого сервиса. Для тестирования можно использовать любой удобный инструмент. Например: в терминале через curl или Postman.
### Будет плюсом:

 - Покрытие кода тестами.
 - Swagger файл для вашего API.
### Основное задание (минимум):

 - Метод создания сегмента. Принимает slug (название) сегмента.
 - Метод удаления сегмента. Принимает slug (название) сегмента.
 - Метод добавления пользователя в сегмент. Принимает список slug (названий) сегментов которые нужно добавить пользователю, список slug (названий) сегментов которые нужно удалить у пользователя, id пользователя.
 - Метод получения активных сегментов пользователя. Принимает на вход id пользователя.

### Доп. задание 1:

Иногда пользователи приходят в поддержку и спрашивают почему у них пропал/появился какой-то новый функционал. Нужно иметь возможность посмотреть когда точно пользователь попал в конкретный сегмент.

**Задача:** реализовать сохранение истории попадания/выбывания пользователя из сегмента с возможностью получения отчета по пользователю за определенный период. На вход: год-месяц. На выходе ссылка на CSV файл.

**Пример отчета:**

идентификатор пользователя 1;сегмент1;операция (добавление/удаление);дата и время

идентификатор пользователя 1;сегмент2;операция (добавление/удаление);дата и время

идентификатор пользователя 2;сегмент3;операция (добавление/удаление);дата и время

### Доп. задание 2:

Бывают ситуации когда нам нужно добавить пользователя в эксперимент на ограниченный срок. Например выдать скидку всего на 2 дня.

**Задача:** реализовать возможность задавать TTL (время автоматического удаления пользователя из сегмента)

**Пример:** Хотим чтобы пользователь попал в сегмент на 2 дня - для этого в метод добавления сегментов пользователю передаём время удаления пользователя из сегмента отдельным полем

### Доп. задание 3:

Мы хотим добавлять пользователя в сегмент не в ручную, а автоматически. В сегмент будет попадать заданный процент пользователей.

**Задача:** в методе создания сегмента, добавить опцию указания процента пользователей, которые будут попадать в сегмент автоматически. В методе получения сегментов пользователя, добавленный сегмент должен отдаваться у заданного процента пользователей.

**Пример:** создали сегмент AVITO_VOICE_MESSAGES и указали что 10% пользователей будут попадать в него автоматически. Пользователь 1000 попал в этот сегмент автоматически. При запросе сегментов пользователя 1000, сегмент AVITO_VOICE_MESSAGES должен отдаваться всегда.

# Результаты

Была реализована программа "минимум", а также все допольнительные задания.

## Описание работы

В процессе работы самостоятельно были приняты следующие решения: 

-- При добавлении пользователя с сегмент, в который он уже был добавлен - ошибки не возникает (аналогично с удалением)
-- Если же пользователя добавили на некоторое время, то время его удаления обновляется
-- В таблице `app.history` избыточность из-за атрибута slug (по хорошему - нужен segment_id), однако, чтобы не делать лишний джойн, была допущена такая избыточность
-- При запросе истории файл сразу скачивается (название файла: `history-<year>-<month>`)
-- В качестве задела на бущее в таблице `app.segments` есть поле `percent` (в будущем это позволит динамически давай или забирать доступы при удалении или добавлении пользователей)
-- Формат даты при запросе истори следующий: `YYYY:MM:DD HH:MM`
-- Удаление "просроченных" доступом реализовано через хранимую функцию в PostgreSQL (`delete_old_accesses`), которая поставлена на `cron` и вызывается каждые 5 минут

## Запуск сервиса

Сервис запускатеся командой `make start` (чтобы поднять сервис локально - `make run` после запуска контейнера с базой)

## Покрытие тестами

Покрытие тестами составляет 67% (модульное тестирование). Чтобы запустить тесты, необходимо из корня прописать команду `make test`

## Swagger

Самостоятельно его можно посмотреть [тут](http://localhost:8001/api/v1/swagger/index.html)

Ниже представлены скины:

![swag1.png](img%2Fswag1.png)
![swag2.png](img%2Fswag2.png)
![swag3.png](img%2Fswag3.png)

## Примеры работы

![example1.png](img%2Fexample1.png)
![example2.png](img%2Fexample2.png)
